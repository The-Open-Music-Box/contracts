/**
 * TheOpenMusicBox API
 * Complete API contract definitions for TheOpenMusicBox - A Raspberry Pi-based music player system.  All API responses follow the UnifiedResponseService format with standardized envelopes. This specification is the source of truth for all client implementations (Web, Flutter, C++). 
 *
 * The version of the OpenAPI document: 3.3.2
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.14.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "TombContracts/model/BackendCapabilities.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {

BackendCapabilities::BackendCapabilities()
{
    m_Upload_formatIsSet = false;
    m_Max_chunk_size = 0;
    m_Max_chunk_sizeIsSet = false;
    m_Player_monitoring = false;
    m_Player_monitoringIsSet = false;
    m_Nfc_available = false;
    m_Nfc_availableIsSet = false;
    m_Led_control = false;
    m_Led_controlIsSet = false;
    m_Backend_typeIsSet = false;
    m_Position_update_interval_ms = 0;
    m_Position_update_interval_msIsSet = false;
    m_Supports_websocket_position = false;
    m_Supports_websocket_positionIsSet = false;
}

BackendCapabilities::~BackendCapabilities()
{
}

void BackendCapabilities::validate()
{
    // TODO: implement validation
}

web::json::value BackendCapabilities::toJson() const
{
    web::json::value val = web::json::value::object();
    if(m_Upload_formatIsSet)
    {   
        
        utility::string_t refVal = fromUpload_formatEnum(m_Upload_format);
        val[utility::conversions::to_string_t(_XPLATSTR("upload_format"))] = ModelBase::toJson(refVal);
        
    }
    if(m_Max_chunk_sizeIsSet)
    {   
        
        val[utility::conversions::to_string_t(_XPLATSTR("max_chunk_size"))] = ModelBase::toJson(m_Max_chunk_size);
    }
    if(m_Player_monitoringIsSet)
    {   
        
        val[utility::conversions::to_string_t(_XPLATSTR("player_monitoring"))] = ModelBase::toJson(m_Player_monitoring);
    }
    if(m_Nfc_availableIsSet)
    {   
        
        val[utility::conversions::to_string_t(_XPLATSTR("nfc_available"))] = ModelBase::toJson(m_Nfc_available);
    }
    if(m_Led_controlIsSet)
    {   
        
        val[utility::conversions::to_string_t(_XPLATSTR("led_control"))] = ModelBase::toJson(m_Led_control);
    }
    if(m_Backend_typeIsSet)
    {   
        
        utility::string_t refVal = fromBackend_typeEnum(m_Backend_type);
        val[utility::conversions::to_string_t(_XPLATSTR("backend_type"))] = ModelBase::toJson(refVal);
        
    }
    if(m_Position_update_interval_msIsSet)
    {   
        
        val[utility::conversions::to_string_t(_XPLATSTR("position_update_interval_ms"))] = ModelBase::toJson(m_Position_update_interval_ms);
    }
    if(m_Supports_websocket_positionIsSet)
    {   
        
        val[utility::conversions::to_string_t(_XPLATSTR("supports_websocket_position"))] = ModelBase::toJson(m_Supports_websocket_position);
    }

    return val;
}

bool BackendCapabilities::fromJson(const web::json::value& val)
{
    bool ok = true;
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("upload_format"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("upload_format")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setUploadFormat;
            ok &= ModelBase::fromJson(fieldValue, refVal_setUploadFormat);
            
            setUploadFormat(toUpload_formatEnum(refVal_setUploadFormat));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("max_chunk_size"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("max_chunk_size")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setMaxChunkSize;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMaxChunkSize);
            setMaxChunkSize(refVal_setMaxChunkSize);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("player_monitoring"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("player_monitoring")));
        if(!fieldValue.is_null())
        {
            bool refVal_setPlayerMonitoring;
            ok &= ModelBase::fromJson(fieldValue, refVal_setPlayerMonitoring);
            setPlayerMonitoring(refVal_setPlayerMonitoring);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("nfc_available"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("nfc_available")));
        if(!fieldValue.is_null())
        {
            bool refVal_setNfcAvailable;
            ok &= ModelBase::fromJson(fieldValue, refVal_setNfcAvailable);
            setNfcAvailable(refVal_setNfcAvailable);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("led_control"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("led_control")));
        if(!fieldValue.is_null())
        {
            bool refVal_setLedControl;
            ok &= ModelBase::fromJson(fieldValue, refVal_setLedControl);
            setLedControl(refVal_setLedControl);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("backend_type"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("backend_type")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setBackendType;
            ok &= ModelBase::fromJson(fieldValue, refVal_setBackendType);
            
            setBackendType(toBackend_typeEnum(refVal_setBackendType));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("position_update_interval_ms"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("position_update_interval_ms")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setPositionUpdateIntervalMs;
            ok &= ModelBase::fromJson(fieldValue, refVal_setPositionUpdateIntervalMs);
            setPositionUpdateIntervalMs(refVal_setPositionUpdateIntervalMs);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("supports_websocket_position"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("supports_websocket_position")));
        if(!fieldValue.is_null())
        {
            bool refVal_setSupportsWebsocketPosition;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSupportsWebsocketPosition);
            setSupportsWebsocketPosition(refVal_setSupportsWebsocketPosition);
            
        }
    }
    return ok;
}

void BackendCapabilities::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(_XPLATSTR(".")))
    {
        namePrefix += utility::conversions::to_string_t(_XPLATSTR("."));
    }
    if(m_Upload_formatIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("upload_format")), fromUpload_formatEnum(m_Upload_format)));
    }
    if(m_Max_chunk_sizeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("max_chunk_size")), m_Max_chunk_size));
    }
    if(m_Player_monitoringIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("player_monitoring")), m_Player_monitoring));
    }
    if(m_Nfc_availableIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("nfc_available")), m_Nfc_available));
    }
    if(m_Led_controlIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("led_control")), m_Led_control));
    }
    if(m_Backend_typeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("backend_type")), fromBackend_typeEnum(m_Backend_type)));
    }
    if(m_Position_update_interval_msIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("position_update_interval_ms")), m_Position_update_interval_ms));
    }
    if(m_Supports_websocket_positionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("supports_websocket_position")), m_Supports_websocket_position));
    }
}

bool BackendCapabilities::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(_XPLATSTR(".")))
    {
        namePrefix += utility::conversions::to_string_t(_XPLATSTR("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("upload_format"))))
    {
        utility::string_t refVal_setUploadFormat;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("upload_format"))), refVal_setUploadFormat );
        setUploadFormat(toUpload_formatEnum(refVal_setUploadFormat));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("max_chunk_size"))))
    {
        int32_t refVal_setMaxChunkSize;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("max_chunk_size"))), refVal_setMaxChunkSize );
        setMaxChunkSize(refVal_setMaxChunkSize);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("player_monitoring"))))
    {
        bool refVal_setPlayerMonitoring;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("player_monitoring"))), refVal_setPlayerMonitoring );
        setPlayerMonitoring(refVal_setPlayerMonitoring);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("nfc_available"))))
    {
        bool refVal_setNfcAvailable;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("nfc_available"))), refVal_setNfcAvailable );
        setNfcAvailable(refVal_setNfcAvailable);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("led_control"))))
    {
        bool refVal_setLedControl;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("led_control"))), refVal_setLedControl );
        setLedControl(refVal_setLedControl);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("backend_type"))))
    {
        utility::string_t refVal_setBackendType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("backend_type"))), refVal_setBackendType );
        setBackendType(toBackend_typeEnum(refVal_setBackendType));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("position_update_interval_ms"))))
    {
        int32_t refVal_setPositionUpdateIntervalMs;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("position_update_interval_ms"))), refVal_setPositionUpdateIntervalMs );
        setPositionUpdateIntervalMs(refVal_setPositionUpdateIntervalMs);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("supports_websocket_position"))))
    {
        bool refVal_setSupportsWebsocketPosition;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("supports_websocket_position"))), refVal_setSupportsWebsocketPosition );
        setSupportsWebsocketPosition(refVal_setSupportsWebsocketPosition);
    }
    return ok;
}

BackendCapabilities::Upload_formatEnum BackendCapabilities::toUpload_formatEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("raw_binary")) {
        return Upload_formatEnum::RAW_BINARY;
    }
    
    if (value == utility::conversions::to_string_t("multipart")) {
        return Upload_formatEnum::MULTIPART;
    }
    
    throw std::invalid_argument("Invalid value for conversion to Upload_formatEnum");
}


const utility::string_t BackendCapabilities::fromUpload_formatEnum(const Upload_formatEnum value) const
{
    switch(value)
    {
        
        case Upload_formatEnum::RAW_BINARY: return utility::conversions::to_string_t("raw_binary");
        
        case Upload_formatEnum::MULTIPART: return utility::conversions::to_string_t("multipart");
        
    }
}

BackendCapabilities::Backend_typeEnum BackendCapabilities::toBackend_typeEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("rpi")) {
        return Backend_typeEnum::RPI;
    }
    
    if (value == utility::conversions::to_string_t("esp32")) {
        return Backend_typeEnum::ESP32;
    }
    
    if (value == utility::conversions::to_string_t("custom")) {
        return Backend_typeEnum::CUSTOM;
    }
    
    throw std::invalid_argument("Invalid value for conversion to Backend_typeEnum");
}


const utility::string_t BackendCapabilities::fromBackend_typeEnum(const Backend_typeEnum value) const
{
    switch(value)
    {
        
        case Backend_typeEnum::RPI: return utility::conversions::to_string_t("rpi");
        
        case Backend_typeEnum::ESP32: return utility::conversions::to_string_t("esp32");
        
        case Backend_typeEnum::CUSTOM: return utility::conversions::to_string_t("custom");
        
    }
}


BackendCapabilities::Upload_formatEnum BackendCapabilities::getUploadFormat() const
{
    return m_Upload_format;
}


void BackendCapabilities::setUploadFormat(const Upload_formatEnum value)
{
    m_Upload_format = value;
    m_Upload_formatIsSet = true;
}

bool BackendCapabilities::uploadFormatIsSet() const
{
    return m_Upload_formatIsSet;
}

void BackendCapabilities::unsetUpload_format()
{
    m_Upload_formatIsSet = false;
}
int32_t BackendCapabilities::getMaxChunkSize() const
{
    return m_Max_chunk_size;
}

void BackendCapabilities::setMaxChunkSize(int32_t value)
{
    m_Max_chunk_size = value;
    m_Max_chunk_sizeIsSet = true;
}

bool BackendCapabilities::maxChunkSizeIsSet() const
{
    return m_Max_chunk_sizeIsSet;
}

void BackendCapabilities::unsetMax_chunk_size()
{
    m_Max_chunk_sizeIsSet = false;
}
bool BackendCapabilities::isPlayerMonitoring() const
{
    return m_Player_monitoring;
}

void BackendCapabilities::setPlayerMonitoring(bool value)
{
    m_Player_monitoring = value;
    m_Player_monitoringIsSet = true;
}

bool BackendCapabilities::playerMonitoringIsSet() const
{
    return m_Player_monitoringIsSet;
}

void BackendCapabilities::unsetPlayer_monitoring()
{
    m_Player_monitoringIsSet = false;
}
bool BackendCapabilities::isNfcAvailable() const
{
    return m_Nfc_available;
}

void BackendCapabilities::setNfcAvailable(bool value)
{
    m_Nfc_available = value;
    m_Nfc_availableIsSet = true;
}

bool BackendCapabilities::nfcAvailableIsSet() const
{
    return m_Nfc_availableIsSet;
}

void BackendCapabilities::unsetNfc_available()
{
    m_Nfc_availableIsSet = false;
}
bool BackendCapabilities::isLedControl() const
{
    return m_Led_control;
}

void BackendCapabilities::setLedControl(bool value)
{
    m_Led_control = value;
    m_Led_controlIsSet = true;
}

bool BackendCapabilities::ledControlIsSet() const
{
    return m_Led_controlIsSet;
}

void BackendCapabilities::unsetLed_control()
{
    m_Led_controlIsSet = false;
}
BackendCapabilities::Backend_typeEnum BackendCapabilities::getBackendType() const
{
    return m_Backend_type;
}


void BackendCapabilities::setBackendType(const Backend_typeEnum value)
{
    m_Backend_type = value;
    m_Backend_typeIsSet = true;
}

bool BackendCapabilities::backendTypeIsSet() const
{
    return m_Backend_typeIsSet;
}

void BackendCapabilities::unsetBackend_type()
{
    m_Backend_typeIsSet = false;
}
int32_t BackendCapabilities::getPositionUpdateIntervalMs() const
{
    return m_Position_update_interval_ms;
}

void BackendCapabilities::setPositionUpdateIntervalMs(int32_t value)
{
    m_Position_update_interval_ms = value;
    m_Position_update_interval_msIsSet = true;
}

bool BackendCapabilities::positionUpdateIntervalMsIsSet() const
{
    return m_Position_update_interval_msIsSet;
}

void BackendCapabilities::unsetPosition_update_interval_ms()
{
    m_Position_update_interval_msIsSet = false;
}
bool BackendCapabilities::isSupportsWebsocketPosition() const
{
    return m_Supports_websocket_position;
}

void BackendCapabilities::setSupportsWebsocketPosition(bool value)
{
    m_Supports_websocket_position = value;
    m_Supports_websocket_positionIsSet = true;
}

bool BackendCapabilities::supportsWebsocketPositionIsSet() const
{
    return m_Supports_websocket_positionIsSet;
}

void BackendCapabilities::unsetSupports_websocket_position()
{
    m_Supports_websocket_positionIsSet = false;
}

}
}
}
}


