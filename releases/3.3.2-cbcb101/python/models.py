# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-11-12T13:56:01+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Optional, Union

from pydantic import AwareDatetime, BaseModel, Field


class Status(Enum):
    success = 'success'
    error = 'error'


class ErrorType(Enum):
    validation_error = 'validation_error'
    not_found = 'not_found'
    rate_limit_exceeded = 'rate_limit_exceeded'
    service_unavailable = 'service_unavailable'
    internal_error = 'internal_error'
    conflict = 'conflict'
    bad_request = 'bad_request'


class UnifiedResponse(BaseModel):
    """
    Standardized response wrapper used by all API endpoints
    """

    status: Status
    message: str
    data: Optional[Union[dict[str, Any], list]] = None
    client_op_id: Optional[str] = Field(
        None, description='Client operation ID for operation tracking'
    )
    server_seq: Optional[float] = Field(
        None, description='Server sequence number for state synchronization'
    )
    timestamp: float = Field(..., description='Unix timestamp in seconds')
    request_id: Optional[str] = None
    error_type: Optional[ErrorType] = None
    details: Optional[dict[str, Any]] = None


class Track(BaseModel):
    number: int = Field(..., description='Track number in playlist')
    title: str
    filename: str
    file_path: Optional[str] = None
    duration: Optional[int] = Field(
        None,
        description='DEPRECATED: Use duration_ms instead for millisecond precision.\nDuration in seconds. Will be removed in v4.0.0.\n',
    )
    duration_ms: Optional[int] = Field(
        None, description='Duration in milliseconds (preferred over duration)'
    )
    artist: Optional[str] = None
    album: Optional[str] = None
    file_size: Optional[int] = None
    created_at: Optional[AwareDatetime] = None
    updated_at: Optional[AwareDatetime] = None


class PlaylistSummary(BaseModel):
    id: str
    title: str
    track_count: int
    nfc_tag_id: Optional[str] = None
    server_seq: Optional[float] = None
    created_at: Optional[AwareDatetime] = None
    updated_at: Optional[AwareDatetime] = None


class PlaylistDetailed(BaseModel):
    id: str
    title: str
    description: Optional[str] = None
    tracks: list[Track]
    nfc_tag_id: Optional[str] = None
    server_seq: Optional[float] = None
    created_at: Optional[AwareDatetime] = None
    updated_at: Optional[AwareDatetime] = None
    total_duration_ms: Optional[int] = None


class PlayerState(BaseModel):
    is_playing: bool
    active_playlist_id: Optional[str] = None
    active_playlist_title: Optional[str] = None
    active_track_id: Optional[str] = None
    active_track: Optional[Track] = None
    active_track_number: Optional[int] = Field(
        None,
        description='Track number in playlist (lightweight alternative to full active_track)',
    )
    active_track_title: Optional[str] = Field(
        None, description='Track title (lightweight alternative to full active_track)'
    )
    track_index: Optional[int] = Field(
        None, description='0-based track index in playlist'
    )
    track_count: Optional[int] = Field(
        None, description='Total number of tracks in playlist'
    )
    position_ms: int = Field(
        ..., description='Current playback position in milliseconds'
    )
    duration_ms: Optional[int] = Field(
        None, description='Track duration in milliseconds'
    )
    can_prev: bool
    can_next: bool
    volume: Optional[int] = Field(None, ge=0, le=100)
    server_seq: float


class NFCAssociation(BaseModel):
    tag_id: str
    playlist_id: str
    playlist_title: str
    created_at: AwareDatetime


class SystemInfo(BaseModel):
    platform: str
    platform_release: str
    platform_version: str
    architecture: str
    hostname: str
    processor: str
    memory_total: Optional[int] = None
    memory_available: Optional[int] = None
    memory_percent: Optional[float] = None
    server_seq: float = Field(
        ..., description='Server sequence number for state synchronization'
    )


class UploadFormat(Enum):
    """
    Format supported for audio file chunk uploads:
    - `raw_binary`: Stream binary data directly (ESP32 - ESPAsyncWebServer body handler)
    - `multipart`: Multipart form-data with 'file' field (RPI - FastAPI File upload)

    """

    raw_binary = 'raw_binary'
    multipart = 'multipart'


class BackendType(Enum):
    """
    Backend platform identifier for debugging and feature-specific adaptations.
    - `rpi`: Raspberry Pi backend (Python/FastAPI)
    - `esp32`: ESP32 firmware backend (C++/Arduino)
    - `custom`: Custom implementation

    """

    rpi = 'rpi'
    esp32 = 'esp32'
    custom = 'custom'


class BackendCapabilities(BaseModel):
    """
    Backend capability flags that declare what features and formats this backend supports.
    Allows Flutter app and other clients to auto-configure based on platform constraints.

    """

    upload_format: UploadFormat = Field(
        ...,
        description="Format supported for audio file chunk uploads:\n- `raw_binary`: Stream binary data directly (ESP32 - ESPAsyncWebServer body handler)\n- `multipart`: Multipart form-data with 'file' field (RPI - FastAPI File upload)\n",
        examples=['raw_binary'],
    )
    max_chunk_size: int = Field(
        ...,
        description='Maximum size of a single chunk in bytes.\n- ESP32: 32768 (32KB) - limited by available heap memory\n- RPI: 1048576 (1MB) - more resources available\n',
        examples=[32768],
        ge=1024,
        le=10485760,
    )
    player_monitoring: Optional[bool] = Field(
        True,
        description='If the backend can monitor audio playback position in real-time.\n- ESP32: false (bandwidth/CPU limited)\n- RPI: true (sufficient resources)\n',
        examples=[False],
    )
    nfc_available: Optional[bool] = Field(
        False,
        description='If NFC reader (PN532) is detected and functional',
        examples=[True],
    )
    led_control: Optional[bool] = Field(
        False, description='If LED control (strip/hat) is available', examples=[True]
    )
    backend_type: Optional[BackendType] = Field(
        None,
        description='Backend platform identifier for debugging and feature-specific adaptations.\n- `rpi`: Raspberry Pi backend (Python/FastAPI)\n- `esp32`: ESP32 firmware backend (C++/Arduino)\n- `custom`: Custom implementation\n',
        examples=['esp32'],
    )
    position_update_interval_ms: Optional[int] = Field(
        500,
        description='Recommended position update frequency in milliseconds.\nFlutter app should use this interval for:\n- Local interpolation timer frequency\n- Expected WebSocket event frequency\n\nTypical values:\n- RPI: 500ms (high-frequency updates)\n- ESP32: 1000-2000ms (reduced network load)\n',
        examples=[1000],
        ge=100,
        le=5000,
    )
    supports_websocket_position: Optional[bool] = Field(
        True,
        description='If backend can send real-time position updates via WebSocket.\nIf false, Flutter app should fall back to HTTP polling.\n\nTypically true for both RPI and ESP32, but allows future backends\nto opt out of WebSocket position streaming.\n',
        examples=[True],
    )


class Status1(Enum):
    healthy = 'healthy'
    degraded = 'degraded'
    unhealthy = 'unhealthy'


class Services(BaseModel):
    api: bool
    audio: bool
    nfc: bool
    gpio: bool
    led_hat: bool
    websocket: bool


class HealthStatus(BaseModel):
    status: Status1
    services: Services
    timestamp: float
    server_seq: float = Field(
        ..., description='Server sequence number for state synchronization'
    )


class UploadSession(BaseModel):
    session_id: str
    playlist_id: str
    filename: str
    file_size: int = Field(..., description='Total file size in bytes')
    chunk_size: int = Field(..., description='Size of each chunk in bytes')
    total_chunks: int = Field(..., description='Total number of chunks')
    file_hash: Optional[str] = Field(
        None, description='Optional file hash for verification'
    )
    created_at: Optional[AwareDatetime] = None


class Status2(Enum):
    pending = 'pending'
    uploading = 'uploading'
    completed = 'completed'
    error = 'error'


class UploadSessionStatus(BaseModel):
    session_id: str
    filename: str
    file_size: int
    chunks_uploaded: int
    chunks_total: int
    progress_percent: float = Field(..., ge=0.0, le=100.0)
    playlist_id: Optional[str] = None
    created_at: Optional[AwareDatetime] = None
    status: Status2


class ChunkUploadResult(BaseModel):
    chunk_index: int
    received: bool
    total_chunks: int
    progress_percent: Optional[float] = None


class Status3(Enum):
    success = 'success'
    error = 'error'


class UploadFinalizeResult(BaseModel):
    status: Status3
    message: str
    track: Optional[Track] = None


class YouTubeSearchResult(BaseModel):
    video_id: str
    title: str
    duration: int = Field(..., description='Duration in seconds')
    thumbnail: Optional[str] = None
    channel: Optional[str] = None


class Status4(Enum):
    pending = 'pending'
    downloading = 'downloading'
    processing = 'processing'
    completed = 'completed'
    failed = 'failed'


class YouTubeDownloadStatus(BaseModel):
    task_id: str
    status: Status4
    progress: Optional[float] = Field(None, ge=0.0, le=100.0)
    error: Optional[str] = None
    track: Optional[Track] = None
