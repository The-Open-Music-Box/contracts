/**
 * TheOpenMusicBox API
 * Complete API contract definitions for TheOpenMusicBox - A Raspberry Pi-based music player system.  All API responses follow the UnifiedResponseService format with standardized envelopes. This specification is the source of truth for all client implementations (Web, Flutter, C++). 
 *
 * The version of the OpenAPI document: 3.3.1
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.14.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * BackendCapabilities.h
 *
 * Backend capability flags that declare what features and formats this backend supports. Allows Flutter app and other clients to auto-configure based on platform constraints. 
 */

#ifndef ORG_OPENAPITOOLS_CLIENT_MODEL_BackendCapabilities_H_
#define ORG_OPENAPITOOLS_CLIENT_MODEL_BackendCapabilities_H_

#include <stdexcept>

#include "TombContracts/ModelBase.h"

#include <cpprest/details/basic_types.h>

namespace org {
namespace openapitools {
namespace client {
namespace model {



/// <summary>
/// Backend capability flags that declare what features and formats this backend supports. Allows Flutter app and other clients to auto-configure based on platform constraints. 
/// </summary>
class TOMB_API BackendCapabilities
    : public ModelBase
{
public:
    BackendCapabilities();
    virtual ~BackendCapabilities();

    /////////////////////////////////////////////
    /// ModelBase overrides

    void validate() override;

    web::json::value toJson() const override;
    bool fromJson(const web::json::value& json) override;

    void toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) const override;
    bool fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) override;


    /////////////////////////////////////////////
    /// BackendCapabilities members

    enum class Upload_formatEnum
    {
        RAW_BINARY,
        MULTIPART,
    };
    /// <summary>
    /// Format supported for audio file chunk uploads: - &#x60;raw_binary&#x60;: Stream binary data directly (ESP32 - ESPAsyncWebServer body handler) - &#x60;multipart&#x60;: Multipart form-data with &#39;file&#39; field (RPI - FastAPI File upload) 
    /// </summary>
    enum class Backend_typeEnum
    {
        RPI,
        ESP32,
        CUSTOM,
    };
    /// <summary>
    /// Backend platform identifier for debugging and feature-specific adaptations. - &#x60;rpi&#x60;: Raspberry Pi backend (Python/FastAPI) - &#x60;esp32&#x60;: ESP32 firmware backend (C++/Arduino) - &#x60;custom&#x60;: Custom implementation 
    /// </summary>

    Upload_formatEnum toUpload_formatEnum(const utility::string_t& value) const;
    const utility::string_t fromUpload_formatEnum(const Upload_formatEnum value) const;


    Backend_typeEnum toBackend_typeEnum(const utility::string_t& value) const;
    const utility::string_t fromBackend_typeEnum(const Backend_typeEnum value) const;


    /// <summary>
    /// Format supported for audio file chunk uploads: - &#x60;raw_binary&#x60;: Stream binary data directly (ESP32 - ESPAsyncWebServer body handler) - &#x60;multipart&#x60;: Multipart form-data with &#39;file&#39; field (RPI - FastAPI File upload) 
    /// </summary>
    Upload_formatEnum getUploadFormat() const;
    bool uploadFormatIsSet() const;
    void unsetUpload_format();
    void setUploadFormat(const Upload_formatEnum value);

    /// <summary>
    /// Maximum size of a single chunk in bytes. - ESP32: 32768 (32KB) - limited by available heap memory - RPI: 1048576 (1MB) - more resources available 
    /// </summary>
    int32_t getMaxChunkSize() const;
    bool maxChunkSizeIsSet() const;
    void unsetMax_chunk_size();
    void setMaxChunkSize(int32_t value);

    /// <summary>
    /// If the backend can monitor audio playback position in real-time. - ESP32: false (bandwidth/CPU limited) - RPI: true (sufficient resources) 
    /// </summary>
    bool isPlayerMonitoring() const;
    bool playerMonitoringIsSet() const;
    void unsetPlayer_monitoring();
    void setPlayerMonitoring(bool value);

    /// <summary>
    /// If NFC reader (PN532) is detected and functional
    /// </summary>
    bool isNfcAvailable() const;
    bool nfcAvailableIsSet() const;
    void unsetNfc_available();
    void setNfcAvailable(bool value);

    /// <summary>
    /// If LED control (strip/hat) is available
    /// </summary>
    bool isLedControl() const;
    bool ledControlIsSet() const;
    void unsetLed_control();
    void setLedControl(bool value);

    /// <summary>
    /// Backend platform identifier for debugging and feature-specific adaptations. - &#x60;rpi&#x60;: Raspberry Pi backend (Python/FastAPI) - &#x60;esp32&#x60;: ESP32 firmware backend (C++/Arduino) - &#x60;custom&#x60;: Custom implementation 
    /// </summary>
    Backend_typeEnum getBackendType() const;
    bool backendTypeIsSet() const;
    void unsetBackend_type();
    void setBackendType(const Backend_typeEnum value);

    /// <summary>
    /// Recommended position update frequency in milliseconds. Flutter app should use this interval for: - Local interpolation timer frequency - Expected WebSocket event frequency  Typical values: - RPI: 500ms (high-frequency updates) - ESP32: 1000-2000ms (reduced network load) 
    /// </summary>
    int32_t getPositionUpdateIntervalMs() const;
    bool positionUpdateIntervalMsIsSet() const;
    void unsetPosition_update_interval_ms();
    void setPositionUpdateIntervalMs(int32_t value);

    /// <summary>
    /// If backend can send real-time position updates via WebSocket. If false, Flutter app should fall back to HTTP polling.  Typically true for both RPI and ESP32, but allows future backends to opt out of WebSocket position streaming. 
    /// </summary>
    bool isSupportsWebsocketPosition() const;
    bool supportsWebsocketPositionIsSet() const;
    void unsetSupports_websocket_position();
    void setSupportsWebsocketPosition(bool value);


protected:
    Upload_formatEnum m_Upload_format;
    bool m_Upload_formatIsSet;

    int32_t m_Max_chunk_size;
    bool m_Max_chunk_sizeIsSet;

    bool m_Player_monitoring;
    bool m_Player_monitoringIsSet;

    bool m_Nfc_available;
    bool m_Nfc_availableIsSet;

    bool m_Led_control;
    bool m_Led_controlIsSet;

    Backend_typeEnum m_Backend_type;
    bool m_Backend_typeIsSet;

    int32_t m_Position_update_interval_ms;
    bool m_Position_update_interval_msIsSet;

    bool m_Supports_websocket_position;
    bool m_Supports_websocket_positionIsSet;

};


}
}
}
}

#endif /* ORG_OPENAPITOOLS_CLIENT_MODEL_BackendCapabilities_H_ */
